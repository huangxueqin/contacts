package com.xueqin.contacts.util;

import android.content.Context;
import android.graphics.Bitmap;
import android.os.Handler;
import android.os.Looper;
import android.text.TextUtils;
import android.util.Log;
import android.util.LruCache;
import android.widget.ImageView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.xueqin.contacts.model.ContactInfo;

import java.lang.ref.WeakReference;
import java.util.LinkedHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * A simple async avatar loading util
 */
public class AvatarLoader {

    private static final String TAG = "AvatarLoader";

    private static AvatarLoader sInstance;

    public static synchronized AvatarLoader getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new AvatarLoader(context);
        }
        return sInstance;
    }

    private Context mContext;
    private LruCache<String, Bitmap> mMemoryCache;
    private ExecutorService mLoadExecutors;
    private Handler mMainHandler;

    private LinkedHashMap<Integer, LoadInfo> mPendingLoadMap;

    private AvatarLoader(Context context) {
        mContext = context.getApplicationContext();
        mMemoryCache = createAvatarCache();
        mLoadExecutors = createAvatarLoadExecutor();
        mMainHandler = new Handler(Looper.getMainLooper());
        mPendingLoadMap = new LinkedHashMap<>();
    }

    /**
     * should call in main thread
     */
    public void loadAvatar(@NonNull final ImageView imageView, @NonNull final ContactInfo contactInfo) {
        final String avatarFileName = contactInfo.getAvatarFileName();
        Log.d(TAG, "start load avatar for " + avatarFileName);
        Bitmap bitmap = mMemoryCache.get(avatarFileName);
        if (bitmap != null) {
            Log.d(TAG, avatarFileName + "is already in cache");
            imageView.setImageBitmap(bitmap);
        } else {
            // normally hashcode is generated by view's physical address
            final int viewId = imageView.hashCode();
            mPendingLoadMap.put(viewId, new LoadInfo(imageView, avatarFileName));
            mLoadExecutors.execute(new AvatarLoadTask(viewId, avatarFileName));
        }
    }

    private class AvatarLoadTask implements Runnable {
        private int viewId;
        private String avatarFileName;

        AvatarLoadTask(int viewId, String avatarFileName) {
            this.viewId = viewId;
            this.avatarFileName = avatarFileName;
        }

        @Override
        public void run() {
            final Bitmap avatar = AssetUtils.loadAvatar(mContext, avatarFileName);
            mMainHandler.post(new Runnable() {
                @Override
                public void run() {
                    LoadInfo li = mPendingLoadMap.get(viewId);
                    if (li != null && TextUtils.equals(li.key, avatarFileName)) {
                        ImageView iv = li.getImageView();
                        if (iv != null) {
                            iv.setImageBitmap(avatar);
                        }
                        // remove from mPendingLoadMap
                        mPendingLoadMap.remove(viewId);
                        // add avatar info memory cache
                        if (avatar != null) {
                            mMemoryCache.put(avatarFileName, avatar);
                        }
                    }
                }
            });
        }
    }

    private static class LoadInfo {
        String key;
        WeakReference<ImageView> viewRef;

        LoadInfo(ImageView imageView, String key) {
            this.viewRef = new WeakReference<>(imageView);
            this.key = key;
        }

        @Nullable
        ImageView getImageView() {
            return viewRef == null ? null : viewRef.get();
        }
    }

    /**
     * choose a proper memory cache size
     * reference: https://developer.android.com/topic/performance/graphics/cache-bitmap#java
     */
    private LruCache<String, Bitmap> createAvatarCache() {
        final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);
        final int cacheSize = maxMemory / 8;
        return new LruCache<String, Bitmap>(cacheSize) {
            @Override
            protected int sizeOf(String key, Bitmap value) {
                return value.getByteCount() / 1024;
            }
        };
    }

    /**
     * create a cache ThreadPoolExecutor with core pool size set to 0 and maximum pool size set to 1
     */
    private ExecutorService createAvatarLoadExecutor() {
        return new ThreadPoolExecutor(0,
                1,
                60L,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue<Runnable>(),
                new ThreadFactory() {
                    @Override
                    public Thread newThread(@NonNull Runnable r) {
                        return new Thread(r, "avatar_load_thread");
                    }
                });
    }
}
