package com.xueqin.contacts.loader;

import android.graphics.Bitmap;
import android.os.Handler;
import android.os.Looper;
import android.text.TextUtils;
import android.util.Log;
import android.util.LruCache;
import android.widget.ImageView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.lang.ref.WeakReference;
import java.util.LinkedHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * A simple async avatar loading util
 * TODO: implement disk cache?
 */
public class SimpleImageLoader {

    private static final String TAG = "SimpleImageLoader";

    private static SimpleImageLoader sInstance;

    public static synchronized SimpleImageLoader getInstance() {
        if (sInstance == null) {
            sInstance = new SimpleImageLoader();
        }
        return sInstance;
    }

    private LruCache<String, Bitmap> mMemoryCache;
    private ExecutorService mLoadExecutors;
    private Handler mMainHandler;
    private ImageDownloader mDownloader = ImageDownloaderKt.getNullDownloader();

    private LinkedHashMap<Integer, LoadInfo> mPendingLoadMap;

    private SimpleImageLoader() {
        mMemoryCache = createAvatarCache();
        mLoadExecutors = createAvatarLoadExecutor();
        mMainHandler = new Handler(Looper.getMainLooper());
        mPendingLoadMap = new LinkedHashMap<>();
    }

    public void setImageDownloader(@NonNull ImageDownloader downloader) {
        mDownloader = downloader;
    }

    /**
     * should call in main thread
     */
    public void loadAvatar(@NonNull final ImageView imageView, @NonNull final String url) {
        if (Looper.myLooper() != Looper.getMainLooper()) {
            Log.w(TAG, "load Avatar should call in main thread!!");
        }
        Log.d(TAG, "start load " + url + "into image view " + imageView);
        Bitmap bitmap = mMemoryCache.get(url);
        if (bitmap != null) {
            Log.d(TAG,  " avatar is already in cache");
            imageView.setImageBitmap(bitmap);
        } else {
            // normally hashcode is generated by view's physical address
            final int viewId = imageView.hashCode();
            mPendingLoadMap.put(viewId, new LoadInfo(imageView, url));
            mLoadExecutors.execute(new AvatarLoadTask(viewId, url));
        }
    }

    private class AvatarLoadTask implements Runnable {
        private int viewId;
        private String url;

        AvatarLoadTask(int viewId, String url) {
            this.viewId = viewId;
            this.url = url;
        }

        @Override
        public void run() {
            final Bitmap avatar = mDownloader.download(url);
            mMainHandler.post(new Runnable() {
                @Override
                public void run() {
                    LoadInfo li = mPendingLoadMap.get(viewId);
                    if (li != null && TextUtils.equals(li.key, url)) {
                        ImageView iv = li.getImageView();
                        if (iv != null) {
                            iv.setImageBitmap(avatar);
                        }
                        // remove from mPendingLoadMap
                        mPendingLoadMap.remove(viewId);
                        // add avatar info memory cache
                        if (avatar != null) {
                            mMemoryCache.put(url, avatar);
                        }
                    }
                }
            });
        }
    }

    private static class LoadInfo {
        String key;
        WeakReference<ImageView> viewRef;

        LoadInfo(ImageView imageView, String key) {
            this.viewRef = new WeakReference<>(imageView);
            this.key = key;
        }

        @Nullable
        ImageView getImageView() {
            return viewRef == null ? null : viewRef.get();
        }
    }

    /**
     * choose a proper memory cache size
     * reference: https://developer.android.com/topic/performance/graphics/cache-bitmap#java
     */
    private LruCache<String, Bitmap> createAvatarCache() {
        final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);
        final int cacheSize = maxMemory / 8;
        return new LruCache<String, Bitmap>(cacheSize) {
            @Override
            protected int sizeOf(String key, Bitmap value) {
                return value.getByteCount() / 1024;
            }
        };
    }

    /**
     * create a cache ThreadPoolExecutor with core pool size set to 0 and maximum pool size set to 1
     */
    private ExecutorService createAvatarLoadExecutor() {
        return new ThreadPoolExecutor(0,
                1,
                60L,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue<Runnable>(),
                new ThreadFactory() {
                    @Override
                    public Thread newThread(@NonNull Runnable r) {
                        return new Thread(r, "avatar_load_thread");
                    }
                });
    }
}
